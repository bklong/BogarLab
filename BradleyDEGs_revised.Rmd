---
title: "BradleyDEGs_revised"
author: "Britt"
date: "2024-10-27"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Assign data to variables:

```{r}
PM.counts <- read.table("Psme_RNASeq_July2024_Psme.1_0_counts.txt", header = TRUE) 
PM.counts

TC.counts <- read.table("Psme_RNASeq_July2024_Trucit1_1_counts.txt", header = TRUE) 
TC.counts
```
Filter counts by retaining only the reads that were over 10 count in at least three samples:

```{r}
TC.counts <- TC.counts[rowSums(TC.counts[,-1] > 10) >= 3,]
TC.counts

PM.counts <- PM.counts[rowSums(PM.counts[,-1] > 10) >= 3,]
PM.counts
```

Remove Transcript ID column (convert dataframe to tibble):

```{r}
library(tibble)

TC.counts.noid <- as_tibble(TC.counts)
TC.counts.noid

PM.counts.noid <- as_tibble(PM.counts)
PM.counts.noid
```

Log transform the counts data: (I am not sure where this is used or if it's needed.)

```{r}
transformed.TC.counts <- log2(TC.counts.noid + 1) 
transformed.PM.counts <- log2(PM.counts.noid + 1)
```

Make tibble with descriptions from counts data table: (this time treating TC or ST as both just "M" for simpler statistical analysis)

```{r}
library(tidyverse)
sample.description <- tibble(sample=colnames(TC.counts.noid))
sample.description <- sample.description %>%
  mutate(
    sp = c("NM", "NM", "NM", "NM", "M", "NM", "M", "M", "M", "NM", "M", "NM", "NM", "M", "NM", "M", "NM", "NM", "NM", "M", "NA"),  
    trt = c("C", "C", "T", "C", "C", "T", "T", "T", "C", "C", "C", "C", "T", "T", "C", "C", "C", "T", "T", "T", "NA"),  
    group = paste(sp, trt, sep = "_")
  )
sample.description <- sample.description %>%
  slice(1:(n() - 1))
sample.description <- sample.description %>%
  mutate(sp=factor(sp, levels = c("NM","M")), 
         trt=factor(trt,levels = c("C","T"))) # setting the levels in this way makes "C and NM" the reference
sample.description
```

DGE Analysis:

```{r}
library(edgeR)

counts.matrix.TC <- TC.counts %>% as.matrix()
counts.matrix.PM <- PM.counts %>% as.matrix()

#remove unassigned row
counts.matrix.TC <- counts.matrix.TC[, -21]
counts.matrix.PM <- counts.matrix.PM[, -21]

counts.matrix.TC
counts.matrix.PM
```

```{r}
dge.data.TC <- DGEList(counts=counts.matrix.TC,
                       group=sample.description$group)
dim(dge.data.TC)
dge.data.TC <- calcNormFactors(dge.data.TC, method = "TMM")
dge.data.TC$samples #look at the normalization factors

dge.data.PM <- DGEList(counts=counts.matrix.PM, 
                    group=sample.description$group)
dim(dge.data.PM) 
dge.data.PM <- calcNormFactors(dge.data.PM, method = "TMM")
dge.data.PM$samples # look at the normalization factors
```

MDS plot:

```{r}
mdsvals <- plotMDS(dge.data.TC, plot = FALSE) # get the MDS values for plotting

tibble(x=mdsvals$x, y=mdsvals$y, sample=rownames(dge.data.TC$samples)) %>%
  inner_join(sample.description) %>%
  ggplot(aes(x=x, y=y, color=trt, shape=sp)) +
  geom_point(size=3) 
```
```{r}
#sample.description is the original descriptive dataset (describes our samples but doesn't have counts data)

design.TC <- model.matrix(~sp+trt,data=sample.description)
rownames(design.TC) <- sample.description$sample
design.TC

design.PM <- model.matrix(~sp+trt,data = sample.description)
rownames(design.PM) <- sample.description$sample
design.PM

design.PM.interaction <- model.matrix(~sp*trt,data = sample.description)
rownames(design.PM.interaction) <- sample.description$sample
design.PM.interaction
```
```{r}
#First the overall dispersion
dge.data.TC <- estimateGLMCommonDisp(dge.data.TC, design.TC, verbose = TRUE)
dge.data.PM <- estimateGLMCommonDisp(dge.data.PM,design.PM,verbose = TRUE)
dge.data.PM.interaction <- estimateGLMCommonDisp(dge.data.PM,design.PM.interaction,verbose = TRUE)

#Then a trended dispersion based on count level
dge.data.TC <- estimateGLMCommonDisp(dge.data.TC,design.TC)
dge.data.PM <- estimateGLMTrendedDisp(dge.data.PM,design.PM)
dge.data.PM.interaction <- estimateGLMTrendedDisp(dge.data.PM.interaction,design.PM.interaction)

#And lastly we calculate the gene-wise dispersion, using the prior estimates to "squeeze" the dispersion towards the common dispersion.
dge.data.TC <- estimateGLMTagwiseDisp(dge.data.TC,design.TC)
dge.data.PM <- estimateGLMTagwiseDisp(dge.data.PM,design.PM)
dge.data.PM.interaction <- estimateGLMTagwiseDisp(dge.data.PM.interaction,design.PM.interaction)
```
```{r}
#this is the full model with all coefficients
#dge.data is the normalized count data
fit.TC <- glmFit(dge.data.TC, design.TC)
fit.PM <- glmFit(dge.data.PM, design.PM)
fit.interaction <- glmFit(dge.data.PM.interaction, design.PM.interaction)

#this model looks at genes differentially expressed between two treatments
trt.lrt.TC <- glmLRT(fit.TC, coef = "trtT")
trt.lrt.PM <- glmLRT(fit.PM,coef = "trtT")
sp.lrt.PM <- glmLRT(fit.PM, coef = "spM")
interaction.lrt.PM <- glmLRT(fit.interaction,coef = "spM:trtT")
```

top 10 DEGs:

```{r}
top10.trt.TC <- topTags(trt.lrt.TC)
top10.trt.PM <- topTags(trt.lrt.PM)
top10.sp.PM <- topTags(sp.lrt.PM) 
top10.interaction.PM <- topTags(interaction.lrt.PM)

top10.trt.TC
top10.trt.PM
top10.sp.PM
top10.interaction.PM
```
summary:

```{r}
summary(decideTestsDGE(trt.lrt.TC,p.value=0.01)) #This uses the FDR.  0.05 would be OK also.
summary(decideTestsDGE(trt.lrt.PM,p.value=0.01)) 
summary(decideTestsDGE(sp.lrt.PM,p.value=0.01))
summary(decideTestsDGE(interaction.lrt.PM,p.value=0.05)) 
```
To summarize above analysis: No significant DEGs found between treatments for the fungal counts (at both 0.01 and 0.05 FDR). Significant DEGs were found (FDR 0.01) between treatments and species for tree counts. The interaction analysis shows no significant DEGs at FDR 0.01 but that increases to 29 significant DEGs at FDR 0.05. These 29 interaction genes are of high interest to our study. The next step is to try and look at the function of these, as well as create visualizations of the data.

Let's make a heat map...

Get normalized and transformed counts:
```{r}
PM.counts.normal.log <- cpm(dge.data.PM,log = TRUE)
TC.counts.normal.log <- cpm(dge.data.TC,log = TRUE)
```

Make basic heatmap:
```{r}
library(pheatmap)
pheatmap(PM.counts.normal.log, scale = "row")
pheatmap(TC.counts.normal.log, scale = "row")
```

make new dataframe to make heatmap that has treatments included in sample labels:

```{r}
PM.counts.normal.log.named <- PM.counts.normal.log
colnames(PM.counts.normal.log.named) <- c("NM_C_001", "NM_C_005", "NM_T_009", "NM_C_016", "M_C_019", "NM_T_023", "M_T_026", "M_T_027", "M_C_030", "NM_C_043", "M_C_045", "NM_C_049", "NM_T_050", "M_T_052", "NM_C_057", "M_C_062", "NM_C_080", "NM_T_082", "NM_T_085", "M_T_087")

PM.counts.normal.log.named
```
```{r}
TC.counts.normal.log.named <- TC.counts.normal.log[, c("DFD_019", "DFD_026", "DFD_027", "DFD_030", "DFD_045", "DFD_052", "DFD_062", "DFD_087")]

colnames(TC.counts.normal.log.named) <- c("C_019", "T_026", "T_027", "C_030", "C_045", "T_052","C_062", "T_087")

TC.counts.normal.log.named 
```
```{r}
pheatmap(PM.counts.normal.log.named, scale = "row")
pheatmap(TC.counts.normal.log.named, scale = "row")
```
subset top genes for heatmap:

```{r}
top50.PM.trt <- rownames(topTags(trt.lrt.PM, n = 50)$table)
top50.PM.trt.named <- PM.counts.normal.log.named[top50.PM.trt, ]

pheatmap(top50.PM.trt.named, scale = "row")
```
```{r}
top50.PM.sp <- rownames(topTags(sp.lrt.PM, n = 50)$table)
top50.PM.sp.named <- PM.counts.normal.log.named[top50.PM.sp, ]

pheatmap(top50.PM.sp.named, scale = "row")
```
```{r}
top15.PM.sp <- rownames(topTags(sp.lrt.PM, n = 15)$table)
top15.PM.sp.named <- PM.counts.normal.log.named[top15.PM.sp, ]

pheatmap(top15.PM.sp.named, scale = "row")
```


```{r}
top50.TC.trt <- rownames(topTags(trt.lrt.TC, n = 50)$table)
top50.TC.trt.named <- TC.counts.normal.log.named[top50.TC.trt, ]

pheatmap(top50.TC.trt.named, scale = "row")
```

```{r}
top50.PM.interaction <- rownames(topTags(interaction.lrt.PM, n = 50)$table)
top50.PM.interaction.named <- PM.counts.normal.log.named[top50.PM.interaction, ]

pheatmap(top50.PM.interaction.named, scale = "row")
```
```{r}
top10.PM.interaction <- rownames(topTags(interaction.lrt.PM, n = 10)$table)
top10.PM.interaction.named <- PM.counts.normal.log.named[top10.PM.interaction, ]

pheatmap(top10.PM.interaction.named, scale = "row")
```




