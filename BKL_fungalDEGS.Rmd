---
title: "BKL_fungalDEGS"
author: "Britt"
date: "2024-07-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Basic steps for DGE Analysis:**

1.  Load the RNAseq counts.
2.  Normalize the counts.
3.  QC the counts.
4.  Create a data frame that describes the experiment.
5.  Determine the dispersion parameter (how over-dispersed is the data?)
6.  Fit a statistical model for gene expression as a function of experimental parameters.
7.  Test the significance of experimental parameters for explaining gene expression.
8.  Examine result.

Start:

**1. Load the RNAseq counts.**

```{bash, eval = FALSE}
#take a look at fungal counts data
head TC_counts.tsv #replace this file with fungal counts that you get back from core
```

```{r}
library(readr)
fungal.counts <- read_tsv("TC_counts.tsv") #assign fungal counts data to an object
fungal.counts
```

```{r}
#retain only the reads that were over 10 count in at least three samples
fungal.counts <- fungal.counts[rowSums(fungal.counts[,-1] > 10) >= 3,]

fungal.counts
```

"We expect that read counts, especially from biological replicates, will be highly correlated. Check to see if this is the case using the `pairs()` function and the `cor()` function. Pairs should be applied to the (potentially log transformed) fungal.counts, NOT the correlation matrix."

**Important Hint:** *`pairs` is slow on the full dataset. Try it on the first 1,000 genes. Do you need to transform to make the pairs output more meaningful?*

**Important Hint2:** *it will be hard to see the pairs plot in the Rstudio inline display. Once you have the plot, click the expand to full window icon to display the plot in its own window.* \*\*Alternatively, instead of using all columns of data, try it on a smaller number of columns \*\*

**Hint 3:** *remember that you will need to remove the \"gene_id\" column before using the data in `pairs` or `cor`*

```{r}
fungal.counts.noid <- fungal.counts[, -which(names(fungal.counts) == "target_id")]
#remove target_id column

fungal.counts.noid
```

```{r}
transformed.counts <- log2(fungal.counts.noid + 1) 
#log transform counts
```

```{r}
cor.table <- cor(fungal.counts.noid)
pairs(transformed.counts)
```

"Once you have a correlation table, use the code provided to visualize it. Then, comment on the results from the pairs and correlation heatmap plots. Are the replicates more similar to each other than they are to other samples? Do you think there are any mistakes in the sample treatment labels?"

```{r}
#rownames(cor.table) <- str_remove(rownames(cor.table), "_INTERNODE.*") #shorter names for better plotting
#colnames(cor.table) <- str_remove(colnames(cor.table), "_INTERNODE.*")

library(tidyverse)

cor.table %>% gplots::heatmap.2(dendrogram="row", trace = "none", col=viridis::viridis(25, begin=.25), margins=c(7,8))
```

**2. Normalize the counts and 3. QC the counts and 4. Make dataframe.**

We will use TTM normalization.

We need to tell EdgeR what groups our samples belong to. In order to do this we'll make a dataframe with our treatments and treatment combos. (drought treatment, inoculation treatment, and combination of both)

```{r}
#make tibble with descriptions from counts data table
sample.description <- tibble(sample=colnames(fungal.counts.noid))

sample.description
```

make three more columns:

1\. column "sp" that has TC or TCS, indicating the inoculation treatment. TC is Trunocolumella citrina only and TCS is T. citrina and Suillus both.

2\. column "trt" that indicates the treatment with either "C" or "T" (control or drought treatment)

3\. column "group" that has sp and trt pasted together with "\_" as a separator. You can use `str_c()` and the "sp" and "trt" columns for this.

```{r}
library(dplyr)
library(stringr)

sample.description <- sample.description %>%
  mutate(
    sp = case_when(
      str_detect(sample, "TCS") ~ "TCS",
      str_detect(sample, "TC") ~ "TC",
      TRUE ~ NA_character_
    ),
    trt = case_when(
      str_detect(sample, "_C") ~ "C",
      str_detect(sample, "_T") ~ "T",
      TRUE ~ NA_character_
    ),
    group = str_c(sp, trt, sep = "_")
  )

sample.description
```

```{r}
sample.description <- sample.description %>%
  mutate(sp=factor(sp), 
         trt=factor(trt,levels = c("C","T"))) # setting the levels in this way makes "C" the reference  

sample.description
```

Calculate Normalization factors:

EdgeR wants numeric data, so we must convert it first. Then we calculate normalization factors using TTM method.

```{r}
#this part seems off
library(edgeR)
counts.matrix <- fungal.counts %>% select(-target_id) %>% as.matrix()
rownames(counts.matrix) <- fungal.counts$target_id

dge.data <- DGEList(counts=counts.matrix, 
                    group=sample.description$group)
dim(dge.data) 
dge.data <- calcNormFactors(dge.data, method = "TMM")
dge.data$samples # look at the normalization factors
```

We can now make an MDS plot to visualize how similar/different our samples our in gene expression. THIS is the bare minimum we should accomplish and put on the poster, but ideally we will dive further into analysis depending on how much time we have.

Make an MDS plot:

```{r}
plotMDS(dge.data)
```

Make a nicer MDS plot:

```{r}
mdsvals <- plotMDS(dge.data, plot = FALSE) # get the MDS values for plotting

tibble(x=mdsvals$x, y=mdsvals$y, sample=rownames(dge.data$samples)) %>%
  inner_join(sample.description) %>%
  ggplot(aes(x=x, y=y, color=trt, shape=sp)) +
  geom_point(size=3) 
```

Extract normalized data:

I'm still not sure why we would log transform the normalized data or not. Here is how we extract the normalized data either way.

```{r}
fungal.counts.normal <- cpm(dge.data) 

# or log2 transformed:
fungal.counts.normal.log <- cpm(dge.data,log = TRUE)
```

**5. Determine the dispersion parameter (how over-dispersed is the data?)**

Calculate dispersion factors:

First we tell EdgeR what our experimental design was. Then, the dispersions.

```{r}
#sample.description is the original descriptive dataset (describes our samples but doesn't have counts data)
design <- model.matrix(~sp+trt,data = sample.description)
rownames(design) <- sample.description$sample
design
```

```{r}
#First the overall dispersion
dge.data <- estimateGLMCommonDisp(dge.data,design,verbose = TRUE)

#Then a trended dispersion based on count level
dge.data <- estimateGLMTrendedDisp(dge.data,design)

#And lastly we calculate the gene-wise dispersion, using the prior estimates to "squeeze" the dispersion towards the common dispersion.
dge.data <- estimateGLMTagwiseDisp(dge.data,design)

#We can examine this with a plot
plotBCV(dge.data)
```

**6. Fit a statistical model for gene expression as a function of experimental parameters.**

To find differentially expressed genes, we basically make linear models for the data that have more or less coefficients. (We compare the full model, with all coefficients, with a model that has one or more coefficients dropped to look at the difference between them.)

```{r}
#this is the full model with all coefficients
#dge.data is the normalized count data
fit <- glmFit(dge.data, design)
```

```{r}
#this model looks at genes differentially expressed in genotype R500 versus the other genotype
#change to our coefficient of interest (likely treatment)
gt.lrt <- glmLRT(fit,coef = "gtR500")
```

**7. Test the significance of experimental parameters for explaining gene expression.**

```{r}
topTags(gt.lrt) # the top 10 most differentially expressed genes between the two genotypes (using the above model)
```

In the resulting table from using topTags,

-   logFC is the log2 fold-change in expression between R500 and IMB211. So a logFC of 2 indicates that the gene is expressed 4 times higher in R500; a logFC of -3 indicates that it is 8 times lower in R500.

-   logCPM is the average expression across all samples.

-   LR is the likelihood ratio: L(Full model) / L(small model) .

-   PValue: unadjusted p-value

-   FDR: False discovery rate (p-value adjusted for multiple testing...this is the one to use)

To summarize:

```{r}
summary(decideTestsDGE(gt.lrt,p.value=0.01)) #This uses the FDR.  0.05 would be OK also.
```

In the table resulting from decideTestsDGE, the Down row is the number of down regulated genes in R500 relative to IMB211 and the Up row is the number of up regulated genes.

If we want to create a table of all differentially expressed genes at a given FDR, then:

```{r}
#Extract genes with a FDR < 0.01 (could also use 0.05)
DEgene.gt <- topTags(gt.lrt,n = Inf,p.value = 0.01)$table

#save to a file
write.csv(DEgene.gt,"../output/DEgenes.gt.csv")

#Or if we want all genes, regardless of FDR:
DEgene.gt.all <- topTags(gt.lrt,n = Inf, p.value = 1)$table
#save to a file
write.csv(DEgene.gt.all,"../output/DEgenes.gt.all.csv")
```

**8. Examine the result.**

Define a function to make a bar graph of genes of interest:

```{r}
plotDE <- function(genes, dge, sample.description) {
  require(ggplot2)
  tmp.data <- t(log2(cpm(dge[genes,])+1))
  tmp.data <- tmp.data %>%
    as.data.frame() %>%
    rownames_to_column("sample") %>%
    left_join(sample.description,by="sample")
  tmp.data <- tmp.data %>%
    pivot_longer(cols=starts_with("Bra"), values_to = "log2_cpm", names_to = "gene")
  pl <- ggplot(tmp.data,aes(x=gt,y=log2_cpm,fill=trt))
  pl <- pl + facet_wrap( ~ gene)
  pl <- pl + ylab("log2(cpm)") + xlab("genotype")
  pl <- pl + geom_boxplot()
  pl + theme(axis.text.x  = element_text(angle=45, vjust=1,hjust=1))
}
```

Use the function plotDE to plot a single gene of interest or the top 9 genes expressed etc:

```{r}
#change according to our genes of interest etc
# A single gene
plotDE("Bra009785",dge.data,sample.description)

#top 9 genes
plotDE(rownames(DEgene.gt)[1:9],dge.data,sample.description)
```

**Gene by Treatment Interaction**

Treatments have effects on treatments. One species of fungus may express genes in response to drought differently than a different species of fungus with the same drought treatment. We can find the genes that change in expression in this way by making a new model that includes this interaction of treatments.

Make the new model:

```{r}
design.interaction <- model.matrix(~sp*trt,data = fungal.counts.new)
rownames(design.interaction) <- fungal.counts.new$sample
design.interaction
```

Now using the new model, do the same steps that we did before to find differentially expressed genes:

```{r}
#First the overall dispersion
dge.data.interaction <- estimateGLMCommonDisp(dge.data,design.interaction,verbose = TRUE)

#Then a trended dispersion based on count level
dge.data.interaction <- estimateGLMTrendedDisp(dge.data,design.interaction)

#And lastly we calculate the gene-wise dispersion, using the prior estimates to "squeeze" the dispersion towards the common dispersion.
dge.data.interaction <- estimateGLMTagwiseDisp(dge.data,design.interaction)

#We can examine this with a plot
plotBCV(dge.data)
```

```{r}
fit.interaction <- glmFit(dge.data.interaction, design.interaction)
```

```{r}
#change coefficients as necessary
gt.lrt.interaction <- glmLRT(fit.interaction,coef = "gtR500:trtDP")
```

```{r}
topTags(gt.lrt.interaction) # the top 10 most differentially expressed genes
```

```{r}
summary(decideTestsDGE(gt.lrt.interaction,p.value=0.01)) #This uses the FDR.  0.05 would be OK also.
```

```{r}
#Extract genes with a FDR < 0.01 (could also use 0.05)
DEgene.gt.interaction <- topTags(gt.lrt.interaction,n = Inf,p.value = 0.01)$table

#save to a file
write.csv(DEgene.gt.interaction,"../output/DEgenes.gt.interaction.csv")

#Or if we want all genes, regardless of FDR:
DEgene.gt.all.interaction <- topTags(gt.lrt.interaction,n = Inf, p.value = 1)$table
#save to a file
write.csv(DEgene.gt.all.interaction,"../output/DEgenes.gt.all.interaction.csv")
```

We already made the function "plotDE"...I need to double check that the below chunk of code doesn't need to be changed for an interaction model. It seems like it doesn't.

```{r}
plotDE <- function(genes, dge, sample.description) {
  require(ggplot2)
  tmp.data <- t(log2(cpm(dge[genes,])+1))
  tmp.data <- tmp.data %>%
    as.data.frame() %>%
    rownames_to_column("sample") %>%
    left_join(sample.description,by="sample")
  tmp.data <- tmp.data %>%
    pivot_longer(cols=starts_with("Bra"), values_to = "log2_cpm", names_to = "gene")
  pl <- ggplot(tmp.data,aes(x=gt,y=log2_cpm,fill=trt))
  pl <- pl + facet_wrap( ~ gene)
  pl <- pl + ylab("log2(cpm)") + xlab("genotype")
  pl <- pl + geom_boxplot()
  pl + theme(axis.text.x  = element_text(angle=45, vjust=1,hjust=1))
}
```

Use plotDE to plot gene expression just like we did for the non-interaction model:

```{r}
# A single gene
plotDE("Bra009785",dge.data.interaction,fungal.counts.new)

#top 9 genes
plotDE(rownames(DEgene.gt.interaction)[1:9],dge.data.interaction,fungal.counts.new)
```
