---
title: "Demorie RNA Analysis Workflow"
author: "Britt"
date: "2024-06-14"
output: html_document
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Basic steps for RNAseq Data Processing:**

1.  Check FASTQ quality.
2.  Trim reads to keep high-quality reads.
3.  Split reads based on barcodes.
4.  Map to reference genome.

(can also map to transcriptome)

**Basic steps for DGE Analysis:**

1.  Load the RNAseq counts.
2.  Normalize the counts.
3.  QC the counts.
4.  Create a data frame that describes the experiment.
5.  Determine the dispersion parameter (how over-dispersed is the data?)
6.  Fit a statistical model for gene expression as a function of experimental parameters.
7.  Test the significance of experimental parameters for explaining gene expression.
8.  Examine result.

## Processing RNAseq Data

Programs needed: FASTQC, Trimmomatic, auto_barcode, STAR

### Index the Reference Genome

```{bash, eval = FALSE}
#download reference genome from personal computer
#this code goes in the personal computer terminal
$ scp -P 22345 /c/Users/britt/Documents/Trucit1_1_AssemblyScaffolds.fasta.gz bklong@bogarprecision.plb.ucdavis.edu:~/DemRNAanalysis/TRCIindex
```

```{bash, eval = FALSE}
#make sure reference genome is unzipped
gunzip -k Psme.1_0.fa.gz
gunzip -k Trucit1_1_AssemblyScaffolds.fasta.gz
```

```{bash, eval = FALSE}
#or use hisat?
hisat2 -x /data/Genomes/HISAT2_index/Psme_1_0_index -1 /data/Test/DFD_001_T14_R1.fastq.gz -2 /data/Test/DFD_001_T14_R2.fastq.gz -S output.sam --summary-file summary.txt --new-summary --mm

# Run STAR genome index generation
~/programs/STAR-2.7.11b/bin/Linux_x86_64_static/STAR --runMode genomeGenerate \
           --genomeDir ~/DemRNAanalysis/PSMEindex \
           --genomeFastaFiles ~/DemRNAanalysis/genome/Psme.1_0.fa \
           --runThreadN 4 \
           --limitGenomeGenerateRAM 6425695398837
```

```{bash, eval = FALSE}
~/programs/STAR-2.7.11b/bin/Linux_x86_64_static/STAR --runMode genomeGenerate \
           --genomeDir ~/DemRNAanalysis/TRCIindex \
           --genomeFastaFiles ~/DemRNAanalysis/TRCIindex/Trucit1_1_AssemblyScaffolds.fasta \
           --runThreadN 4 \
           --limitGenomeGenerateRAM 6425695398837
           
#need to modify overhang parameter (max read length - 1)
#need annotation file for TRCI
STAR \
    --runThreadN 7 \
    --runMode genomeGenerate \
    --genomeDir TRCIindex \
    --genomeSAindexNbases 12 \
    --sjdbOverhang 93 \ 
    --sjdbGTFfile Brapa_gene_v1.5.gff \
    --sjdbGTFfeatureExon CDS \
    --sjdbGTFtagExonParentTranscript Parent \
    --genomeFastaFiles Trucit1_1_AssemblyScaffolds.fasta
```

### Check Quality of Reads

```{bash, eval = FALSE}
fastqc
#then load file of interest into user interface
```

### Trim Low Quality Reads if Necessary

```{bash, eval = FALSE}
#this is an example
trimmomatic SE GH.lane67.fastq.gz GH.lane67.trimmed.fastq SLIDINGWINDOW:4:20 MINLEN:50
trimmomatic SE GH.lane67.fastq.gz GH.lane67.trimmed.fastq SLIDINGWINDOW:4:20 MINLEN:50
trimmomatic SE -threads 1 GH.lane67.fastq.gz GH.lane67.trimmed.fastq SLIDINGWINDOW:4:20 MINLEN:50
trimmomatic SE -threads 1 GH.lane67.fastq.gz GH.lane67.trimmed.fastq SLIDINGWINDOW:4:20 MINLEN:50
```

If you trim reads, make sure you put them through FASTQC again to see if it worked.

### Splitting by Barcodes

```{bash, eval = FALSE}
#use auto_barcode to split reads
```

### Check Quality of Libraries

```{bash, eval = FALSE}
fastqc --threads 7 -o ../../output/fastqc_out split_fq/*.fq

multiqc fastqc_out
```

### Map Reads to Reference

```{bash, eval = FALSE}
#modify this to be a for loop for all fastq files
time STAR --runThreadN 7 \
--genomeDir input/Brapa_reference/Brapa_STAR_index \
--readFilesIn input/Brapa_fastq/split_fq/IMB211_DP_1_SILIQUE.fq \
--outFileNamePrefix output/STARout/IMB211_DP_1_SILIQUE.fq_ \
--outSAMtype BAM SortedByCoordinate \
--outBAMsortingThreadN 2 \
--alignIntronMax 5000
```

## Differential Gene Expression

Programs needed: HTseq-count

### Get Read Counts

```{bash, eval = FALSE}
#example
htseq-count -s no -t CDS -i Parent \
../../assignment-09-jnmaloof/output/STAR_out-IMB211_INTERNODE_A03/IMB211_INTERNODE_Aligned_A03.bam \
../../assignment-09-jnmaloof/output/STAR_out-R500_INTERNODE_A03/R500_INTERNODE_Aligned_A03.bam \
../../assignment-09-jnmaloof/input/Brapa_reference/Brapa_gene_v1.5.gff > A03_counts.tsv
```

\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

### DGE With Counts Data

#### (start here after bioinformatics core returns counts data)

```{bash, eval = FALSE}
#take a look at counts data
head A03_counts.tsv #replace this file with what you get back from core
```

```{r}
library(readr)
counts.data <- read_tsv("../input/gh_internode_counts2.tsv") #assign counts data to an object
```

"You may have noticed that the first gene_id is labelled"\*". These are the reads that did not map to a gene. Let's remove this row from the data. Also let's replace any"NA" records with "0" because that is what NA means in this case."

```{r}
#change NAs to 0s

library(tidyverse)

counts.data <- counts.data %>% filter(gene_id!="*")
counts.data[is.na(counts.data)] <- 0

head(counts.data)
```

"The column names are too long. Use the `str_remove()` command to remove the".1_matched.merged.fq.bam" suffix from each column name. Although it doesn't matter in this case, surrounding the "pattern" inside of the function `fixed()` would be a good idea, because "." is a wildcard character."

```{r}
#shorten column names
library(stringr)

colnames(counts.data) <- str_remove(colnames(counts.data), fixed(".1_matched.merged.fq.bam"))

colnames(counts.data)
```

```{r}
#retain only the reads that were over 10 count in at least three samples
counts.data <- counts.data[rowSums(counts.data[,-1] > 10) >= 3,]
```

"We expect that read counts, especially from biological replicates, will be highly correlated. Check to see if this is the case using the `pairs()` function and the `cor()` function. Pairs should be applied to the (potentially log transformed) counts.data, NOT the correlation matrix."

```{r}
#the below code needs to be fixed
counts_subset <- counts.data[, -which(names(counts.data) == "gene_id")]
counts_subset <- counts_subset[1:1000, ]
correlation <- cor(counts_subset)
pairs(correlation)

transformed_counts <- log2(counts_subset + 1) 
transformed_correlation <- cor(transformed_counts)
pairs(transformed_correlation)
```

"Once you have a correlation table, use the code provided to visualize it. Then, comment on the results from the pairs and correlation heatmap plots. Are the replicates more similar to each other than they are to other samples? Do you think there are any mistakes in the sample treatment labels?"

```{r}
rownames(cor.table) <- str_remove(rownames(cor.table), "_INTERNODE.*") #shorter names for better plotting
colnames(cor.table) <- str_remove(colnames(cor.table), "_INTERNODE.*")

cor.table %>% gplots::heatmap.2(dendrogram="row", trace = "none", col=viridis::viridis(25, begin=.25), margins=c(7,8))
```

Data Normalization:

```{r}
#make tibble with descriptions from counts data table
sample.description <- tibble(sample=colnames(counts.data)[-1])

head(sample.description)
```

make three more columns:

1\.
column "gt" that has either IMB211 or R500, indicating the genotype

2\.
column "trt" that indicates the treatment with either "C" or "T" (control or drought treatment)

3\.
column "group" that has gt and trt pasted together with "\_" as a separator.
You can use `str_c()` and the "gt" and "trt" columns for this.

```{r}
library(dplyr)
library(stringr)

counts.data.new <- sample.description %>%
  mutate(
    gt = str_extract(sample, "(IMB211|R500)"),  
    trt = str_extract(sample, "(NDP|DP)"),     
    group = str_c(gt, trt, sep = "_")              
  )

head(counts.data.new)
```

```{r}
counts.data.new <- counts.data.new %>%
  mutate(gt=factor(gt), 
         trt=factor(trt,levels = c("NDP","DP"))) # setting the levels in this way makes "NDP" the reference  

counts.data.new
```

Normalization factors:

```{r}
library(edgeR)
counts.matrix <- counts.data %>% select(-gene_id) %>% as.matrix()
rownames(counts.matrix) <- counts.data$gene_id

dge.data <- DGEList(counts=counts.matrix, 
                    group=sample.description$group)
dim(dge.data) 
dge.data <- calcNormFactors(dge.data, method = "TMM")
dge.data$samples # look at the normalization factors
```

Make an MDS plot:

```{r}
plotMDS(dge.data)
```

Make a nicer plot:

```{r}
mdsvals <- plotMDS(dge.data, plot = FALSE) # get the MDS values for plotting

tibble(x=mdsvals$x, y=mdsvals$y, sample=rownames(dge.data$samples)) %>%
  inner_join(sample.description) %>%
  ggplot(aes(x=x, y=y, color=trt, shape=gt)) +
  geom_point(size=3) 
```

Extract normalized data:

```{r}
counts.data.normal <- cpm(dge.data) 

# or log2 transformed:
counts.data.normal.log <- cpm(dge.data,log = TRUE)
```

Calculate dispersion factors:

```{r}
design <- model.matrix(~gt+trt,data = sample.description)
rownames(design) <- sample.description$sample
design
```

```{r}
#First the overall dispersion
dge.data <- estimateGLMCommonDisp(dge.data,design,verbose = TRUE)

#Then a trended dispersion based on count level
dge.data <- estimateGLMTrendedDisp(dge.data,design)

#And lastly we calculate the gene-wise dispersion, using the prior estimates to "squeeze" the dispersion towards the common dispersion.
dge.data <- estimateGLMTagwiseDisp(dge.data,design)

#We can examine this with a plot
plotBCV(dge.data)
```

Find Differentially Expressed Genes:

```{r}
fit <- glmFit(dge.data, design)
```

```{r}
gt.lrt <- glmLRT(fit,coef = "gtR500")
```

```{r}
topTags(gt.lrt) # the top 10 most differentially expressed genes
```

```{r}
summary(decideTestsDGE(gt.lrt,p.value=0.01)) #This uses the FDR.  0.05 would be OK also.
```

```{r}
#Extract genes with a FDR < 0.01 (could also use 0.05)
DEgene.gt <- topTags(gt.lrt,n = Inf,p.value = 0.01)$table

#save to a file
write.csv(DEgene.gt,"../output/DEgenes.gt.csv")

#Or if we want all genes, regardless of FDR:
DEgene.gt.all <- topTags(gt.lrt,n = Inf, p.value = 1)$table
#save to a file
write.csv(DEgene.gt.all,"../output/DEgenes.gt.all.csv")
```

```{r}
plotDE <- function(genes, dge, sample.description) {
  require(ggplot2)
  tmp.data <- t(log2(cpm(dge[genes,])+1))
  tmp.data <- tmp.data %>%
    as.data.frame() %>%
    rownames_to_column("sample") %>%
    left_join(sample.description,by="sample")
  tmp.data <- tmp.data %>%
    pivot_longer(cols=starts_with("Bra"), values_to = "log2_cpm", names_to = "gene")
  pl <- ggplot(tmp.data,aes(x=gt,y=log2_cpm,fill=trt))
  pl <- pl + facet_wrap( ~ gene)
  pl <- pl + ylab("log2(cpm)") + xlab("genotype")
  pl <- pl + geom_boxplot()
  pl + theme(axis.text.x  = element_text(angle=45, vjust=1,hjust=1))
}
```

```{r}
# A single gene
plotDE("Bra009785",dge.data,sample.description)

#top 9 genes
plotDE(rownames(DEgene.gt)[1:9],dge.data,sample.description)
```

Gene by Treatment Interaction

```{r}
design.interaction <- model.matrix(~gt*trt,data = counts.data.new)
rownames(design.interaction) <- counts.data.new$sample
design.interaction
```

```{r}
#First the overall dispersion
dge.data.interaction <- estimateGLMCommonDisp(dge.data,design.interaction,verbose = TRUE)

#Then a trended dispersion based on count level
dge.data.interaction <- estimateGLMTrendedDisp(dge.data,design.interaction)

#And lastly we calculate the gene-wise dispersion, using the prior estimates to "squeeze" the dispersion towards the common dispersion.
dge.data.interaction <- estimateGLMTagwiseDisp(dge.data,design.interaction)

#We can examine this with a plot
plotBCV(dge.data)
```

```{r}
fit.interaction <- glmFit(dge.data.interaction, design.interaction)
```

```{r}
gt.lrt.interaction <- glmLRT(fit.interaction,coef = "gtR500:trtDP")
```

```{r}
topTags(gt.lrt.interaction) # the top 10 most differentially expressed genes
```

```{r}
summary(decideTestsDGE(gt.lrt.interaction,p.value=0.01)) #This uses the FDR.  0.05 would be OK also.
```

```{r}
#Extract genes with a FDR < 0.01 (could also use 0.05)
DEgene.gt.interaction <- topTags(gt.lrt.interaction,n = Inf,p.value = 0.01)$table

#save to a file
write.csv(DEgene.gt.interaction,"../output/DEgenes.gt.interaction.csv")

#Or if we want all genes, regardless of FDR:
DEgene.gt.all.interaction <- topTags(gt.lrt.interaction,n = Inf, p.value = 1)$table
#save to a file
write.csv(DEgene.gt.all.interaction,"../output/DEgenes.gt.all.interaction.csv")
```

```{r}
plotDE <- function(genes, dge, sample.description) {
  require(ggplot2)
  tmp.data <- t(log2(cpm(dge[genes,])+1))
  tmp.data <- tmp.data %>%
    as.data.frame() %>%
    rownames_to_column("sample") %>%
    left_join(sample.description,by="sample")
  tmp.data <- tmp.data %>%
    pivot_longer(cols=starts_with("Bra"), values_to = "log2_cpm", names_to = "gene")
  pl <- ggplot(tmp.data,aes(x=gt,y=log2_cpm,fill=trt))
  pl <- pl + facet_wrap( ~ gene)
  pl <- pl + ylab("log2(cpm)") + xlab("genotype")
  pl <- pl + geom_boxplot()
  pl + theme(axis.text.x  = element_text(angle=45, vjust=1,hjust=1))
}
```

```{r}
# A single gene
plotDE("Bra009785",dge.data.interaction,counts.data.new)

#top 9 genes
plotDE(rownames(DEgene.gt.interaction)[1:9],dge.data.interaction,counts.data.new)
```

Next Steps:

Now that we know which genes are differentially expressed by their ID, what follow up questions would we like to pursue?

1.  What types of genes are differentially expressed?
    This can be asked at the individual gene level and also at the group level

2.  What patterns of differential expression do we observe in our data?

3.  Are there any common promoter motifs among the differentially expressed genes?
    Such motifs could allow us to form testable hypotheses about the transcription factors responsible for the differential expression.

GO Enrichment Analysis (Assignment 11 from 180L)

```{r}
library(tidyverse)
library(goseq)
library(rtracklayer)
library(GenomicRanges)
library(Biostrings)
```

```{r}
DEgene.trt <- read_csv("../input/DEgenes.trt.csv")
head(DEgene.trt)
colnames(DEgene.trt)[1] <- "GeneID"
head(DEgene.trt)
```

"Import the gene descriptions that you downloaded (File S9, above); pay attention to the `read_tsv`\"col_names\" argument. What is appropriate here? Use one of the `join()` functions (which one?) to add gene descriptions for the genes found to be regulated by the NDP/DP treatment. Output a table of the top **10** genes (based on FDR) that includes the output from edgeR and the descriptions. Have the description be the first (left-most) column so that you can see it in the output (*Hint: use tidyverse `select`, but be sure to keep the other columns*)."

```{r}
gene_descriptions <- read_tsv("../input/FileS9.txt", col_names = c("GeneID", "description"))

gene_descriptions
```

```{r}
genes <- left_join(DEgene.trt, gene_descriptions, by = "GeneID")

genes
```

```{r}
top_10_genes <- genes %>% 
  arrange(FDR) %>% 
  select(description, everything()) %>% 
  head(10)

top_10_genes
```

assign data to objects:

```{r}
go.terms <- read_tsv("../input/FileS11.txt",col_names=FALSE)
head(go.terms)
colnames(go.terms) <- c("GeneID","GO")
head(go.terms)

expressed.genes <- read_tsv("../input/internode_expressed_genes.txt")
head(expressed.genes)
names(expressed.genes) <- "GeneID"

gene.lengths <- read_tsv("../input/Brapa_CDS_lengths.txt")
head(gene.lengths)

#we need to reduce the gene.length data to only contain entries for those genes in our expressed.genes set.  We also need this as a vector
gene.lengths.vector <- gene.lengths$Length[gene.lengths$GeneID %in% expressed.genes$GeneID]
names(gene.lengths.vector) <- gene.lengths$GeneID[gene.lengths$GeneID %in% expressed.genes$GeneID]
head(gene.lengths.vector)

#Do the reverse to make sure everything matches up (it seems that we don't have length info for some genes?)
expressed.genes.match <- expressed.genes[expressed.genes$GeneID %in% names(gene.lengths.vector),]
```

formatting data:

```{r}
go.list <- strsplit(go.terms$GO,split=",")
names(go.list) <- go.terms$GeneID
head(go.list)
```

```{r}
#for each gene in expressed gene, return FALSE if it is not in DEgene.trt and TRUE if it is.
DE.trt <- expressed.genes.match$GeneID %in% DEgene.trt$GeneID
names(DE.trt) <- expressed.genes.match$GeneID
head(DE.trt)

DE.trt <- as.numeric(DE.trt) #convert to 0s and 1s
head(DE.trt)
sum(DE.trt) # number of DE genes
```

calculate over-representation:

```{r}
#determines if there is bias due to gene length.  The plot shows the relationship.
nullp.result <- nullp(DEgenes = DE.trt,bias.data = gene.lengths.vector)

#calculate p-values for each GO term
rownames(nullp.result) <- names(gene.lengths.vector) #because of a bug in nullp()
GO.out <- goseq(pwf = nullp.result,gene2cat = go.list,test.cats=("GO:BP"))
 
#list over-represented GO terms (p < 0.05) 
GO.out[GO.out$over_represented_pvalue < 0.05,]
```

GO Visualization

```{r}
write.table(GO.out[GO.out$over_represented_pvalue < 0.05,1:2],row.names=FALSE,file="../output/GO_terms.txt", quote = FALSE,col.names = FALSE)
```

Cut and paste the GO terms and p-values into REVIGO.

Use <http://revigo.irb.hr/> (REVIGO) to visualize enrichment.
(use website)

Clustering (Assignment 12)

Co-Expression (Assignment 13)
